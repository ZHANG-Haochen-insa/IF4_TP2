# TP2 移动机器人应用 - 实验报告

**INSA 里昂, TP2 IF4 实时系统, 2025-2026**

**学生姓名:** [填写姓名]

**日期:** 2025年11月28日

---

## 1. 引言

本实验的目标是在ESP32微控制器上实现移动机器人的开环控制，同时保证实时操作。通过使用FreeRTOS实时操作系统，我们实现了基于PWM信号的电机控制。

---

## 2. 第一部分：PWM信号生成 (2.1)

### 2.1 实验目标

实现一个程序，使机器人按照以下顺序执行动作：
1. 等待1秒
2. 前进500毫秒
3. 等待500毫秒
4. 后退500毫秒
5. 永久停止

### 2.2 实现方法

#### 2.2.1 PWM配置

我们使用ESP32的LEDC模块来生成PWM信号，配置参数如下：

```c
#define PWM_FREQ 1000        // PWM频率：1kHz
#define PWM_RESOLUTION 15    // PWM分辨率：15位 (0-32767)
```

PWM初始化函数使用 `ledcAttach()` 将PWM通道绑定到指定的GPIO引脚：

```c
void init_motor_pwm(uint8_t pin) {
  ledcAttach(pin, PWM_FREQ, PWM_RESOLUTION);
  analogWrite(pin, 0);  // 初始占空比为0
}
```

#### 2.2.2 电机引脚定义

根据硬件连接，电机控制引脚定义如下：

| 电机 | 前进引脚 | 后退引脚 |
|------|----------|----------|
| 左电机 | MLF = 26 | MLB = 25 |
| 右电机 | MRF = 33 | MRB = 32 |

#### 2.2.3 电机控制函数

我们实现了三个基本的电机控制函数：

1. **停止函数 `stopMotors()`**：将所有PWM输出设为0
2. **前进函数 `moveForward(speed)`**：左右电机同时正转
3. **后退函数 `moveBackward(speed)`**：左右电机同时反转

```c
void moveForward(uint8_t speed) {
  uint32_t pwm_value = (PWM_MAX * speed) / 100;
  // 左电机前进，右电机前进
  analogWrite(MLF, pwm_value);
  analogWrite(MLB, 0);
  analogWrite(MRF, pwm_value);
  analogWrite(MRB, 0);
}
```

> **注意**：在控制电机时，必须确保反向信号（前进时的后退引脚，后退时的前进引脚）保持为0，以避免H桥短路。

#### 2.2.4 FreeRTOS任务实现

我们采用了**双任务架构**：

1. **Setup/Loop任务**：负责硬件初始化，完成后挂起自己
2. **MotorControl任务**：负责执行电机控制序列

电机控制任务的实现：

```c
void motorControlTask(void *pvParameters) {
  Serial.println("Motor control task started");
  
  // 1. 等待500毫秒
  vTaskDelay(pdMS_TO_TICKS(500));
  
  // 2. 前进500毫秒
  moveForward(MOTOR_SPEED);
  vTaskDelay(pdMS_TO_TICKS(500));
  
  // 3. 等待500毫秒
  stopMotors();
  vTaskDelay(pdMS_TO_TICKS(500));
  
  // 4. 后退500毫秒
  moveBackward(MOTOR_SPEED);
  vTaskDelay(pdMS_TO_TICKS(500));
  
  // 5. 停止
  stopMotors();
  
  // 任务完成后删除自己
  vTaskDelete(NULL);
}
```

#### 2.2.5 任务创建与调度

在 `setup()` 函数中创建任务：

```c
xTaskCreate(
  motorControlTask,    // 任务函数
  "MotorControl",      // 任务名称
  2048,                // 堆栈大小
  NULL,                // 任务参数
  1,                   // 任务优先级
  NULL                 // 任务句柄
);
```

为了防止 `loop()` 函数被执行干扰任务运行，我们在 `setup()` 结束时挂起当前任务：

```c
TaskHandle_t setup_task = xTaskGetCurrentTaskHandle();
vTaskSuspend(setup_task);
```

### 2.3 程序流程图

```
┌─────────────────┐
│     setup()     │
├─────────────────┤
│ 初始化串口      │
│ 初始化PWM引脚   │
│ 初始化编码器    │
│ 创建电机控制任务│
│ 挂起当前任务    │
└────────┬────────┘
         │
         ▼
┌─────────────────────────┐
│   motorControlTask()    │
├─────────────────────────┤
│ 等待 500ms              │
│ 前进 500ms              │
│ 停止，等待 500ms        │
│ 后退 500ms              │
│ 停止                    │
│ 删除任务                │
└─────────────────────────┘
```

### 2.4 实验结果

程序烧录后，串口输出如下：
```
Setup start : openloop
Setup complete, motor control task created
Motor control task started
Waiting 0.5 second...
Moving forward for 0.5 second...
Waiting 500ms...
Moving backward for 0.5 second...
Stopping motors
Motor control task completed
```

机器人成功按照预定序列执行了前进和后退动作。

### 2.5 遇到的问题与解决方案

#### 问题1：`loop()` 函数不断执行

**现象**：串口不断输出 "loop function is running !!?? :-("

**原因**：在Arduino-ESP32框架中，`setup()` 和 `loop()` 运行在同一个FreeRTOS任务中。`setup()` 执行完后会自动进入 `loop()`。

**解决方案**：在 `setup()` 结束时使用 `vTaskSuspend()` 挂起当前任务：
```c
TaskHandle_t setup_task = xTaskGetCurrentTaskHandle();
vTaskSuspend(setup_task);
```

#### 问题2：`vTaskSuspend()` 参数错误

**现象**：编译错误或程序行为异常

**原因**：`vTaskSuspend()` 需要传入任务句柄参数，不能直接调用 `vTaskSuspend()`。

**解决方案**：先获取当前任务句柄，再传入：
```c
TaskHandle_t setup_task = xTaskGetCurrentTaskHandle();
vTaskSuspend(setup_task);
```

---

## 3. 第二部分：测量转速 (2.2)

### 3.1 实验目标

实现一个多任务程序，使用中断方法：
1. 每100毫秒测量一次左轮的转速
2. 通过串口将速度数据发送到PC
3. 持续运行10秒
4. 扩展程序以同时显示两个轮子的速度

### 3.2 实现方法

#### 3.2.1 编码器原理

增量式编码器有两个输出通道（A相和B相），产生相位差90°的方波信号。通过检测这两个信号的状态变化，可以确定：
- **转动方向**：通过A、B相的相位关系判断
- **转动速度**：通过单位时间内的脉冲数计算

我们采用**四倍频解码**方式，即在A、B两相的上升沿和下降沿都进行计数，提高测量分辨率。

#### 3.2.2 编码器引脚定义

| 编码器 | A相引脚 | B相引脚 |
|--------|---------|---------|
| 左编码器 | SLA = 14 | SLB = 27 |
| 右编码器 | SRA = 35 | SRB = 34 |

#### 3.2.3 编码器参数配置

```c
#define ENCODER_PPR 11  // 编码器每转脉冲数
#define GEAR_RATIO 30   // 减速比
// 每转的总脉冲数 = PPR × 减速比 × 4 (四倍频)
#define PULSES_PER_REV (ENCODER_PPR * GEAR_RATIO * 4)  // = 1320
```

#### 3.2.4 中断服务程序 (ISR)

我们为每个编码器的A、B两相分别配置了中断服务程序，使用**双边沿触发**（CHANGE）模式：

```c
void IRAM_ATTR leftEncoderISR_A() {
  uint8_t A = digitalRead(SLA);
  uint8_t B = digitalRead(SLB);
  uint8_t currentState = (A << 1) | B;
  
  // 根据状态转换判断方向
  // 正转: 00->01->11->10->00
  // 反转: 00->10->11->01->00
  int8_t direction = 0;
  switch (lastLeftState) {
    case 0b00:
      if (currentState == 0b01) direction = 1;
      else if (currentState == 0b10) direction = -1;
      break;
    case 0b01:
      if (currentState == 0b11) direction = 1;
      else if (currentState == 0b00) direction = -1;
      break;
    case 0b11:
      if (currentState == 0b10) direction = 1;
      else if (currentState == 0b01) direction = -1;
      break;
    case 0b10:
      if (currentState == 0b00) direction = 1;
      else if (currentState == 0b11) direction = -1;
      break;
  }
  
  leftEncoderCount += direction;
  lastLeftState = currentState;
}
```

> **注意**：`IRAM_ATTR` 属性确保中断服务程序存储在内部RAM中，提高执行速度。

#### 3.2.5 编码器状态转换图

四倍频解码的状态转换如下：

```
正转方向 →
    ┌───┐   ┌───┐   ┌───┐   ┌───┐
A: ─┘   └───┘   └───┘   └───┘   └──
      ┌───┐   ┌───┐   ┌───┐   ┌───┐
B: ───┘   └───┘   └───┘   └───┘   └

状态: 00 → 01 → 11 → 10 → 00 → ...

← 反转方向
状态: 00 → 10 → 11 → 01 → 00 → ...
```

#### 3.2.6 共享资源保护

由于编码器计数器会在中断中被修改，在主任务中读取时需要保护：

```c
// 临界区保护用的自旋锁
portMUX_TYPE spinlock = portMUX_INITIALIZER_UNLOCKED;

int32_t getAndResetLeftEncoder() {
  portENTER_CRITICAL(&spinlock);
  int32_t count = leftEncoderCount;
  leftEncoderCount = 0;
  portEXIT_CRITICAL(&spinlock);
  return count;
}
```

使用 `portENTER_CRITICAL` / `portEXIT_CRITICAL` 确保读取和重置操作的原子性，防止数据竞争。

#### 3.2.7 速度计算

角速度计算公式：

$$\omega = \frac{N}{N_{rev}} \times \frac{2\pi}{T}$$

其中：
- $\omega$：角速度 (rad/s)
- $N$：测量周期内的脉冲数
- $N_{rev}$：每转的总脉冲数 (PULSES_PER_REV = 1320)
- $T$：测量周期 (秒)

代码实现：

```c
float calculateAngularVelocity(int32_t pulseCount, uint32_t periodMs) {
  float revolutions = (float)pulseCount / PULSES_PER_REV;
  float timeSeconds = (float)periodMs / 1000.0;
  return (revolutions * 2.0 * PI) / timeSeconds;
}
```

#### 3.2.8 多任务架构

程序采用三个任务：

| 任务名称 | 优先级 | 功能 |
|----------|--------|------|
| SpeedMeasure | 2 (高) | 每100ms测量并输出速度 |
| MotorControl | 1 (低) | 控制电机运行 |
| Setup/Loop | - | 初始化后挂起 |

速度测量任务使用 `vTaskDelayUntil()` 实现精确的周期性执行：

```c
void speedMeasureTask(void *pvParameters) {
  TickType_t xLastWakeTime = xTaskGetTickCount();
  uint32_t elapsedTime = 0;
  const uint32_t totalTimeMs = TOTAL_RUN_TIME_S * 1000;
  
  while (elapsedTime < totalTimeMs) {
    vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(SPEED_MEASURE_PERIOD_MS));
    
    // 获取编码器计数并重置
    int32_t leftCount = getAndResetLeftEncoder();
    int32_t rightCount = getAndResetRightEncoder();
    
    // 计算角速度
    float leftSpeed = calculateAngularVelocity(leftCount, SPEED_MEASURE_PERIOD_MS);
    float rightSpeed = calculateAngularVelocity(rightCount, SPEED_MEASURE_PERIOD_MS);
    
    elapsedTime += SPEED_MEASURE_PERIOD_MS;
    
    // 输出数据
    Serial.print(elapsedTime);
    Serial.print("\t");
    Serial.print(leftSpeed, 3);
    Serial.print("\t");
    Serial.println(rightSpeed, 3);
  }
}
```

### 3.3 程序流程图

```
┌─────────────────────────────────────────────────────────────┐
│                        setup()                               │
├─────────────────────────────────────────────────────────────┤
│ 初始化串口                                                   │
│ 初始化PWM引脚                                                │
│ 初始化编码器引脚 + 配置中断                                   │
│ 创建 speedMeasureTask (优先级 2)                             │
│ 创建 motorControlTask (优先级 1)                             │
│ 挂起当前任务                                                 │
└─────────────────────────────────────────────────────────────┘
         │
         ├───────────────────────────┐
         ▼                           ▼
┌─────────────────────┐    ┌─────────────────────┐
│  speedMeasureTask   │    │  motorControlTask   │
├─────────────────────┤    ├─────────────────────┤
│ 每100ms:            │    │ 等待1秒             │
│  - 读取编码器计数   │    │ 前进5秒             │
│  - 计算角速度       │    │ 后退5秒             │
│  - 串口输出数据     │    │ 停止电机            │
│ 持续10秒           │    │ 删除任务            │
└─────────────────────┘    └─────────────────────┘
         │
         ▼
┌─────────────────────┐
│    中断服务程序      │
├─────────────────────┤
│ A/B相边沿触发时:    │
│  - 读取当前状态     │
│  - 判断转动方向     │
│  - 更新脉冲计数     │
└─────────────────────┘
```

### 3.4 串口输出格式

数据以制表符分隔的格式输出，便于导入Excel分析：

```
Time(ms)	Left(rad/s)	Right(rad/s)
100	2.345	2.301
200	2.412	2.389
300	2.398	2.367
...
```

### 3.5 实验结果

程序烧录后，串口输出示例：
```
Setup start: Speed Measurement with Interrupts
Setup complete, tasks created
Motor control task started
Speed measurement task started
Time(ms)	Left(rad/s)	Right(rad/s)
100	0.000	0.000
...
1100	2.385	2.412
1200	2.401	2.389
...
6100	-2.356	-2.378
...
Speed measurement completed
```

### 3.6 遇到的问题与解决方案

#### 问题1：中断中访问共享变量

**现象**：偶尔出现速度值异常跳变

**原因**：主任务读取计数器时，中断可能同时修改该值，导致数据不一致

**解决方案**：使用 `portENTER_CRITICAL` / `portEXIT_CRITICAL` 保护临界区

#### 问题2：速度计算结果为零

**现象**：电机运行但计算出的速度始终为0

**原因**：编码器参数设置错误（PPR或减速比）

**解决方案**：根据实际编码器规格调整 `ENCODER_PPR` 和 `GEAR_RATIO` 参数

#### 问题3：`vTaskDelay` vs `vTaskDelayUntil`

**现象**：测量周期不稳定

**原因**：`vTaskDelay` 是相对延时，会累积误差

**解决方案**：使用 `vTaskDelayUntil` 实现绝对延时，确保精确的周期性

---

## 4. 总结

本实验成功实现了基于FreeRTOS的移动机器人开环控制和速度测量程序。主要收获包括：

1. **PWM控制**：掌握了ESP32 LEDC模块的使用方法，能够配置PWM频率和分辨率
2. **FreeRTOS任务管理**：理解了任务创建、延时和挂起的机制
3. **实时系统设计**：学会了使用 `vTaskDelay()` 和 `vTaskDelayUntil()` 实现精确的时间控制
4. **中断编程**：掌握了ESP32中断配置和中断服务程序的编写
5. **编码器解码**：理解了四倍频解码原理，提高测量分辨率
6. **共享资源保护**：学会使用临界区保护共享变量，避免数据竞争

采用多任务架构的优势在于：
- 将初始化逻辑、控制逻辑和测量逻辑分离
- 便于后续扩展（如添加闭环控制、通信任务等）
- 符合实时系统的设计原则
- 各任务可以独立调试和验证

---

## 附录：完整代码

- **2.1 PWM信号生成**：`base_IF4_TP2_BO_v2024_1/base_IF4_TP2_BO_v2024_1.ino`
- **2.2 测量转速**：`BO_Vitesse/BO_Vitesse.ino`

---

*报告完成日期：2025年11月28日*
