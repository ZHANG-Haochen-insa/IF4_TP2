# TP2 移动机器人应用 - 实验报告

**INSA 里昂, TP2 IF4 实时系统, 2025-2026**

**学生姓名:** [填写姓名]

**日期:** 2025年11月28日

---

## 1. 引言

本实验的目标是在ESP32微控制器上实现移动机器人的开环控制，同时保证实时操作。通过使用FreeRTOS实时操作系统，我们实现了基于PWM信号的电机控制。

---

## 2. 第一部分：PWM信号生成 (2.1)

### 2.1 实验目标

实现一个程序，使机器人按照以下顺序执行动作：
1. 等待1秒
2. 前进500毫秒
3. 等待500毫秒
4. 后退500毫秒
5. 永久停止

### 2.2 实现方法

#### 2.2.1 PWM配置

我们使用ESP32的LEDC模块来生成PWM信号，配置参数如下：

```c
#define PWM_FREQ 1000        // PWM频率：1kHz
#define PWM_RESOLUTION 15    // PWM分辨率：15位 (0-32767)
```

PWM初始化函数使用 `ledcAttach()` 将PWM通道绑定到指定的GPIO引脚：

```c
void init_motor_pwm(uint8_t pin) {
  ledcAttach(pin, PWM_FREQ, PWM_RESOLUTION);
  analogWrite(pin, 0);  // 初始占空比为0
}
```

#### 2.2.2 电机引脚定义

根据硬件连接，电机控制引脚定义如下：

| 电机 | 前进引脚 | 后退引脚 |
|------|----------|----------|
| 左电机 | MLF = 26 | MLB = 25 |
| 右电机 | MRF = 33 | MRB = 32 |

#### 2.2.3 电机控制函数

我们实现了三个基本的电机控制函数：

1. **停止函数 `stopMotors()`**：将所有PWM输出设为0
2. **前进函数 `moveForward(speed)`**：左右电机同时正转
3. **后退函数 `moveBackward(speed)`**：左右电机同时反转

```c
void moveForward(uint8_t speed) {
  uint32_t pwm_value = (PWM_MAX * speed) / 100;
  // 左电机前进，右电机前进
  analogWrite(MLF, pwm_value);
  analogWrite(MLB, 0);
  analogWrite(MRF, pwm_value);
  analogWrite(MRB, 0);
}
```

> **注意**：在控制电机时，必须确保反向信号（前进时的后退引脚，后退时的前进引脚）保持为0，以避免H桥短路。

#### 2.2.4 FreeRTOS任务实现

我们采用了**双任务架构**：

1. **Setup/Loop任务**：负责硬件初始化，完成后挂起自己
2. **MotorControl任务**：负责执行电机控制序列

电机控制任务的实现：

```c
void motorControlTask(void *pvParameters) {
  Serial.println("Motor control task started");
  
  // 1. 等待500毫秒
  vTaskDelay(pdMS_TO_TICKS(500));
  
  // 2. 前进500毫秒
  moveForward(MOTOR_SPEED);
  vTaskDelay(pdMS_TO_TICKS(500));
  
  // 3. 等待500毫秒
  stopMotors();
  vTaskDelay(pdMS_TO_TICKS(500));
  
  // 4. 后退500毫秒
  moveBackward(MOTOR_SPEED);
  vTaskDelay(pdMS_TO_TICKS(500));
  
  // 5. 停止
  stopMotors();
  
  // 任务完成后删除自己
  vTaskDelete(NULL);
}
```

#### 2.2.5 任务创建与调度

在 `setup()` 函数中创建任务：

```c
xTaskCreate(
  motorControlTask,    // 任务函数
  "MotorControl",      // 任务名称
  2048,                // 堆栈大小
  NULL,                // 任务参数
  1,                   // 任务优先级
  NULL                 // 任务句柄
);
```

为了防止 `loop()` 函数被执行干扰任务运行，我们在 `setup()` 结束时挂起当前任务：

```c
TaskHandle_t setup_task = xTaskGetCurrentTaskHandle();
vTaskSuspend(setup_task);
```

### 2.3 程序流程图

```
┌─────────────────┐
│     setup()     │
├─────────────────┤
│ 初始化串口      │
│ 初始化PWM引脚   │
│ 初始化编码器    │
│ 创建电机控制任务│
│ 挂起当前任务    │
└────────┬────────┘
         │
         ▼
┌─────────────────────────┐
│   motorControlTask()    │
├─────────────────────────┤
│ 等待 500ms              │
│ 前进 500ms              │
│ 停止，等待 500ms        │
│ 后退 500ms              │
│ 停止                    │
│ 删除任务                │
└─────────────────────────┘
```

### 2.4 实验结果

程序烧录后，串口输出如下：
```
Setup start : openloop
Setup complete, motor control task created
Motor control task started
Waiting 0.5 second...
Moving forward for 0.5 second...
Waiting 500ms...
Moving backward for 0.5 second...
Stopping motors
Motor control task completed
```

机器人成功按照预定序列执行了前进和后退动作。

### 2.5 遇到的问题与解决方案

#### 问题1：`loop()` 函数不断执行

**现象**：串口不断输出 "loop function is running !!?? :-("

**原因**：在Arduino-ESP32框架中，`setup()` 和 `loop()` 运行在同一个FreeRTOS任务中。`setup()` 执行完后会自动进入 `loop()`。

**解决方案**：在 `setup()` 结束时使用 `vTaskSuspend()` 挂起当前任务：
```c
TaskHandle_t setup_task = xTaskGetCurrentTaskHandle();
vTaskSuspend(setup_task);
```

#### 问题2：`vTaskSuspend()` 参数错误

**现象**：编译错误或程序行为异常

**原因**：`vTaskSuspend()` 需要传入任务句柄参数，不能直接调用 `vTaskSuspend()`。

**解决方案**：先获取当前任务句柄，再传入：
```c
TaskHandle_t setup_task = xTaskGetCurrentTaskHandle();
vTaskSuspend(setup_task);
```

---

## 3. 总结

本实验成功实现了基于FreeRTOS的移动机器人开环控制程序。主要收获包括：

1. **PWM控制**：掌握了ESP32 LEDC模块的使用方法，能够配置PWM频率和分辨率
2. **FreeRTOS任务管理**：理解了任务创建、延时和挂起的机制
3. **实时系统设计**：学会了使用 `vTaskDelay()` 实现精确的时间控制

采用双任务架构的优势在于：
- 将初始化逻辑与控制逻辑分离
- 便于后续扩展（如添加编码器读取任务、通信任务等）
- 符合实时系统的设计原则

---

## 附录：完整代码

完整代码请参见 `base_IF4_TP2_BO_v2024_1/base_IF4_TP2_BO_v2024_1.ino`

---

*报告完成日期：2025年11月28日*
